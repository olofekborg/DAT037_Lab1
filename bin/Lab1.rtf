{\rtf1\ansi\ansicpg1252\cocoartf1347\cocoasubrtf570
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\f0\fs24 \cf0 The code is tested with a text file containing test cases with different combinations of numbers, both positive and negative, integers and non-integers. The test file gives the expected results and error messages. Since we\'92ve tested all these different cases we consider our test file to be good enough, and since the code also passed the given test file, we consider the code to be correct. \
\
Since the set is halved each turn, the length of the array N and the maximum amount of iterations k is gives the equation N/(2^k)=1. This equation is given by the worse case scenario, where the  binary search has to iterate  until there is only one element left. This gives that k=log2(N), and the time complexity is therefore O(logN). The best case scenario is that the element is given immediately, and therefore theta can not be calculated.\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf0 One iteration in our binary search implementation is O(1) since each step in the code has constant time complexity. Therefore, the reasoning above is also relevant for our specific implementation. }